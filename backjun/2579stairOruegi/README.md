# 백준 2579 계단오르기

## 해결 알고리즘

- dynamic programming

- 현재 위치의 계단을 i라고 했을 때 이전 칸이 연속적이지 않은 경우 dp\[i\]\[0\], 이전 칸이 연속적인 경우 dp\[i\]\[1\] 라고 한다.

  - i-4에서 i-2로 2칸 뛰고 i 칸으로 또 2칸 뛴 경우 : 0
  - i-3에서 i-2로 1칸 뛰고 i 칸으로 2칸 뛴 경우: 0
  - i-3에서 i-1로 2칸 뛰면 무조건 i칸으로 1칸 뛰어야 함: 1

- 따라서 다음과 같은 점화식을 세울 수 있다.

  ```c++
  dp[i][0] = max(dp[i-2][1], dp[i-2][0]) + <계단 i값>;
  dp[i][1] = dp[i-1][0] + <계단 i값>;
  ```

  - dp\[i-2\]\[1\]: i-5에서 i-4로 1칸 뛰고 i-2로 2칸 뛴 경우
  - dp\[i-2\]\[0\]: i-6에서 i-4로 2칸 뛰고 i-2로 2칸 뛴 경우
  - dp\[i\]\[0\] 는 연속하는 값이나 연속 안하는 값이나 가능하기 때문에 둘 중 하나의 최대값을 골라야한다.
  - dp\[i\]\[1\] 는 3번 연달아 1칸씩 오를 수 없기 때문에 i-3 칸에서 i-1로 2칸 뛰어야 하는 경우만 존재한다.